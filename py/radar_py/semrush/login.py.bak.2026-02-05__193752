from __future__ import annotations

import json
import os
import re
import time
from pathlib import Path
from typing import Any, Dict, Optional, Tuple


def needs_login(page) -> bool:
    u = (page.url or "").lower()
    if "login" in u:
        return True
    try:
        if page.locator('input[type="password"]').count() > 0:
            return True
    except Exception:
        pass
    return False


def load_semrush_creds(req: Dict[str, Any]) -> Tuple[Optional[str], Optional[str]]:
    # 1) req
    e = (req.get("semrush_email") or "").strip() or None
    p = (req.get("semrush_password") or "").strip() or None
    if e and p:
        return e, p

    # 2) env
    e = (os.environ.get("SEMRUSH_EMAIL") or "").strip() or None
    p = (os.environ.get("SEMRUSH_PASSWORD") or "").strip() or None
    if e and p:
        return e, p

    # 3) json file
    secrets_file = (req.get("semrush_secrets_file") or os.environ.get("SEMRUSH_SECRETS_FILE") or "").strip()
    if not secrets_file:
        return None, None

    try:
        raw = json.loads(Path(secrets_file).read_text(encoding="utf-8"))
        if not isinstance(raw, dict):
            return None, None
        e = (raw.get("email") or raw.get("user") or "").strip() or None
        p = (raw.get("password") or raw.get("pass") or "").strip() or None
        return e, p
    except Exception:
        return None, None


def shot_viewport(page, out_dir: Path, filename: str) -> str:
    out_dir.mkdir(parents=True, exist_ok=True)
    path = out_dir / filename
    page.screenshot(path=str(path), full_page=False)
    return filename


def scroll_top(page) -> None:
    page.evaluate("() => window.scrollTo(0, 0)")
    page.wait_for_timeout(400)


def goto(page, url: str) -> None:
    page.goto(url, wait_until="domcontentloaded")
    try:
        page.wait_for_load_state("networkidle", timeout=12_000)
    except Exception:
        pass
    page.wait_for_timeout(400)


def click_login_submit(page) -> None:
    try:
        btn = page.get_by_role("button", name=re.compile(r"(log\s*in|sign\s*in|continue)", re.I)).first
        if btn.count() > 0:
            btn.click()
            return
    except Exception:
        pass

    try:
        loc = page.locator('button[type="submit"], input[type="submit"]').first
        if loc.count() > 0:
            loc.click()
            return
    except Exception:
        pass


def auto_login(page, email: str, password: str) -> None:
    try:
        email_loc = page.locator(
            'input[type="email"], input[name="email"], input[name="login"], input[autocomplete="email"]'
        ).first
        if email_loc.count() == 0:
            email_loc = page.locator('input[placeholder*="email" i], input[placeholder*="e-mail" i]').first
        if email_loc.count() > 0:
            email_loc.fill(email)
    except Exception:
        pass

    try:
        pass_loc = page.locator(
            'input[type="password"], input[name="password"], input[autocomplete="current-password"]'
        ).first
        if pass_loc.count() > 0:
            pass_loc.fill(password)
    except Exception:
        pass

    try:
        click_login_submit(page)
    except Exception:
        pass


def wait_for_login(
    page,
    out_dir: Path,
    name_prefix: str,
    *,
    headless: bool,
    email: Optional[str],
    password: Optional[str],
) -> None:
    if not needs_login(page):
        return

    scroll_top(page)
    shot_viewport(page, out_dir, f"{name_prefix}__login_needed.png")

    if email and password:
        auto_login(page, email, password)

    if headless:
        # headless: ручной логин невозможен, но авто-логин возможен
        if email and password:
            t0 = time.time()
            while time.time() - t0 < 60:
                if not needs_login(page):
                    return
                page.wait_for_timeout(1000)
            scroll_top(page)
            shot_viewport(page, out_dir, f"{name_prefix}__login_still_needed.png")
        else:
            page.wait_for_timeout(1500)
        return

    t0 = time.time()
    while time.time() - t0 < 600:
        if not needs_login(page):
            return
        page.wait_for_timeout(1000)

